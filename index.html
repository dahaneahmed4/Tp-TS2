
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>TP Nº2 – Filtres numériques | Master 1 AII – USTHB</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Police Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- MathJax pour équations -->
    <script>
        window.MathJax = {
            tex: {inlineMath: [['\\(', '\\)'], ['$', '$']]}
        };
    </script>
    <script id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    <!-- Plotly.js pour graphiques interactifs -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <style>
        :root {
            --bg-color: #050914;
            --bg-gradient: radial-gradient(circle at top, #2f1363 0, #050914 55%, #02030a 100%);
            --accent-color: #9b5cff;
            --accent-color-2: #00f0ff;
            --accent-soft: rgba(155, 92, 255, 0.18);
            --text-color: #e5e9ff;
            --muted-text: #9aa4d4;
            --card-bg: rgba(8, 13, 33, 0.9);
            --code-bg: #050816;
        }

        * { box-sizing: border-box; }

        body {
            font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            line-height: 1.7;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            background: var(--bg-gradient);
            background-attachment: fixed;
        }

        header {
            padding: 1.8rem 2rem 1.4rem 2rem;
            background: linear-gradient(120deg, rgba(5, 9, 20, 0.95), rgba(35, 12, 88, 0.95));
            border-bottom: 1px solid rgba(155, 92, 255, 0.4);
            box-shadow: 0 10px 25px rgba(0,0,0,0.6);
            position: sticky;
            top: 0;
            z-index: 50;
        }

        header h1 {
            margin: 0;
            font-weight: 600;
            font-size: 1.6rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        header h2 {
            margin: 0.2rem 0 0.4rem 0;
            font-weight: 400;
            font-size: 0.95rem;
            color: var(--muted-text);
        }

        header p {
            margin: 0;
            font-size: 0.85rem;
            color: var(--muted-text);
        }

        main {
            max-width: 1200px;
            margin: 2rem auto 3rem auto;
            padding: 0 1.2rem;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 1.8rem 2rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(155, 92, 255, 0.25);
            box-shadow: 0 18px 40px rgba(0,0,0,0.7);
        }

        h2 {
            margin-top: 0;
            font-size: 1.3rem;
            font-weight: 600;
            letter-spacing: 0.04em;
            text-transform: uppercase;
        }

        h3 {
            font-size: 1.1rem;
            font-weight: 500;
            margin-top: 1.4rem;
        }

        h4 {
            font-size: 1rem;
            font-weight: 500;
            margin-top: 1rem;
        }

        p, li {
            font-size: 0.95rem;
        }

        ul { padding-left: 1.2rem; }

        .section-number {
            color: var(--accent-color-2);
            font-weight: 600;
            margin-right: 0.4rem;
        }

        .toc {
            background: radial-gradient(circle at top left, rgba(155, 92, 255, 0.22), rgba(5, 9, 20, 0.95));
            border-radius: 16px;
            padding: 1.4rem 1.6rem;
            border: 1px solid rgba(155, 92, 255, 0.45);
        }

        .toc a {
            color: var(--accent-color-2);
            text-decoration: none;
        }

        .toc a:hover { text-decoration: underline; }

        pre {
            background: var(--code-bg);
            color: #eaeaea;
            padding: 0.9rem 1rem;
            border-radius: 10px;
            overflow-x: auto;
            font-size: 0.85rem;
            border: 1px solid rgba(0, 240, 255, 0.28);
        }

        code {
            font-family: Consolas, "Fira Code", "Courier New", monospace;
        }

        footer {
            text-align: center;
            font-size: 0.8rem;
            color: var(--muted-text);
            padding: 1.4rem 1rem 1.8rem 1rem;
        }
    </style>
</head>

<body>

<header>
    <h1>TP Nº2 – Filtres numériques</h1>
    <h2>Master 1 AII – USTHB</h2>
    <p>Responsable : F. Achouri • Étudiant : DAHANE AHMED LAMINE</p>
</header>

<main>

    <!-- 0. Introduction -->
    <section id="introduction" class="card">
        <h2><span class="section-number">0.</span>Introduction générale</h2>
        <p>
            Ce deuxième TP de traitement du signal est consacré à l’étude des <strong>filtres numériques</strong> à temps discret.
            Après avoir manipulé les signaux élémentaires, les séries de Fourier et la convolution dans le TP1, nous passons
            ici à la modélisation, l’analyse et la synthèse de filtres RIF (Réponse Impulsionnelle Finie) et RII
            (Réponse Impulsionnelle Infinie).
        </p>
        <p>
            Un filtre numérique est décrit soit par une <strong>équation récurrente</strong> dans le domaine temporel,
            soit par une <strong>fonction de transfert</strong> \(H(z)\) dans le domaine de Z. L’objectif de ce TP est de
            relier ces représentations, d’analyser la <strong>stabilité</strong> via les pôles, et d’étudier les
            <strong>réponses impulsionnelles</strong> et <strong>réponses fréquentielles</strong>.
        </p>
        <p>
            Les objectifs pédagogiques sont :
        </p>
        <ul>
            <li>Manipuler les signaux numériques de base \(\delta(n)\) et \(u(n)\).</li>
            <li>Construire la fonction de transfert \(H(z)\) à partir d’une équation récurrente.</li>
            <li>Analyser la stabilité d’un filtre à partir de la position de ses pôles dans le plan Z.</li>
            <li>Visualiser et interpréter le module et la phase de la réponse fréquentielle.</li>
            <li>Synthétiser des filtres passe-bas répondant à des spécifications fréquentielles données.</li>
        </ul>
    </section>

    <!-- Plan -->
    <section class="card toc">
        <h3>Plan du document</h3>
        <ul>
            <li><a href="#manip1"><span class="section-number">1.</span>Manipulation 1 – Signaux numériques \(\delta(n)\), \(u(n)\)</a></li>
            <li><a href="#manip2"><span class="section-number">2.</span>Manipulation 2 – Analyse de filtres RIF et RII</a></li>
            <li><a href="#manip3"><span class="section-number">3.</span>Manipulation 3 – Synthèse de filtres passe-bas (RII et RIF)</a></li>
            <li><a href="#conclusion"><span class="section-number">4.</span>Conclusion générale</a></li>
        </ul>
    </section>

    <!-- 1. Manipulation 1 -->
    <section id="manip1" class="card">
        <h2><span class="section-number">1.</span>Manipulation 1 – Signaux numériques \(\delta(n)\) et \(u(n)\)</h2>

        <p>
            L’énoncé demande d’écrire un script MATLAB permettant d’afficher les signaux numériques suivants :
            \(\delta(n)\), \(\delta(n-1)\), \(u(n)\) et \(u(n-1)\), où \(\delta(n)\) et \(u(n)\) sont respectivement
            l’impulsion de Dirac et l’échelon unitaire à temps discret.
        </p>

        <h3>1.1 Script MATLAB – Génération et affichage des signaux</h3>

        <pre><code>% Manipulation 1 : Signaux numériques delta(n), delta(n-1), u(n), u(n-1)

clear all; close all; clc;

% Axe des instants discrets
n = -5:5;

% Impulsion de Dirac delta(n)
delta = (n == 0);

% Impulsion décalée delta(n-1)
delta1 = (n == 1);

% Échelon unitaire u(n)
u = (n >= 0);

% Échelon décalé u(n-1)
u1 = (n >= 1);

figure(1);
subplot(2,2,1);
stem(n, delta, 'filled');
grid on;
title('\delta(n)');
xlabel('n'); ylabel('Amplitude');

subplot(2,2,2);
stem(n, delta1, 'filled');
grid on;
title('\delta(n-1)');
xlabel('n'); ylabel('Amplitude');

subplot(2,2,3);
stem(n, u, 'filled');
grid on;
title('u(n)');
xlabel('n'); ylabel('Amplitude');

subplot(2,2,4);
stem(n, u1, 'filled');
grid on;
title('u(n-1)');
xlabel('n'); ylabel('Amplitude');
        </code></pre>

        <h3>1.2 Graphes interactifs – \(\delta(n)\), \(\delta(n-1)\), \(u(n)\), \(u(n-1)\)</h3>
        <p>
            Les graphiques suivants permettent de visualiser de manière interactive les signaux utilisés comme briques
            de base pour exciter les filtres numériques.
        </p>

        <div id="plot_delta"></div>
        <div id="plot_delta1"></div>
        <div id="plot_u"></div>
        <div id="plot_u1"></div>

        <h3>1.3 Commentaires et observations</h3>
        <ul>
            <li>\(\delta(n)\) est nul partout sauf en \(n = 0\), où il vaut 1. Il sert à définir la réponse impulsionnelle d’un filtre.</li>
            <li>\(\delta(n-1)\) est simplement \(\delta(n)\) décalé d’un échantillon vers la droite (retard d’un pas).</li>
            <li>\(u(n)\) vaut 0 pour \(n < 0\) et 1 pour \(n \ge 0\) : c’est la version discrète de l’échelon unitaire.</li>
            <li>\(u(n-1)\) introduit un retard d’un échantillon pour le front de montée de l’échelon.</li>
        </ul>
        <p>
            Ces signaux serviront ensuite à analyser le comportement des filtres RIF et RII, notamment à travers leur
            réponse impulsionnelle et leur réponse à un échelon.
        </p>
    </section>

    <!-- 2. Manipulation 2 – Analyse de filtres RIF et RII -->
    <section id="manip2" class="card">
        <h2><span class="section-number">2.</span>Manipulation 2 – Analyse de filtres RIF et RII</h2>

        <p>
            Cette manipulation comporte deux parties :
        </p>
        <ul>
            <li><strong>2.1</strong> Analyse d’un filtre numérique RIF simple.</li>
            <li><strong>2.2</strong> Analyse d’un filtre numérique RII d’ordre 2.</li>
        </ul>

        <!-- 2.1 RIF -->
        <h3>2.1 Analyse d’un filtre numérique RIF</h3>

        <p>
            L’énoncé considère un filtre numérique de type RIF décrit par l’équation récurrente :
        </p>
        <p>
            

\[
                y(n) = 0{,}5\,x(n) + 0{,}5\,x(n-1)
            \]


        </p>
        <p>
            On reconnaît ici un filtre qui effectue la moyenne de l’échantillon courant et du précédent.
            Intuitivement, il agit comme un <strong>filtre passe-bas lissant</strong>.
        </p>

        <h4>2.1.1 Fonction de transfert \(H(z)\)</h4>
        <p>
            En appliquant la transformée en Z (en supposant des conditions initiales nulles) :
        </p>
        <p>
            

\[
            Y(z) = 0{,}5\,X(z) + 0{,}5\,z^{-1}X(z)
                 = X(z)\left(0{,}5 + 0{,}5\,z^{-1}\right)
            \]


        </p>
        <p>
            La fonction de transfert est donc :
        </p>
        <p>
            

\[
            H(z) = \frac{Y(z)}{X(z)} = 0{,}5 + 0{,}5\,z^{-1}
                 = \frac{0{,}5z + 0{,}5}{z}
            \]


        </p>
        <p>
            Le numérateur est \(0{,}5z + 0{,}5\) et le dénominateur est \(z\), ce qui correspond à un
            <strong>zéro en</strong> \(z = -1\) et un <strong>pôle en</strong> \(z = 0\).
        </p>

        <h4>2.1.2 Script MATLAB – \(H(z)\), \(h(n)\), \(H(\omega)\), pôles et zéros</h4>

        <pre><code>% Manipulation 2.1 : Filtre RIF y(n) = 0.5 x(n) + 0.5 x(n-1)

clear all; close all; clc;

Fe = 8000;      % fréquence d'échantillonnage (Hz)
N  = 512;       % nombre de points pour la réponse fréquentielle

% Coefficients du filtre RIF (en z^-1)
num = [0.5 0.5];   % numérateur H(z) = 0.5 + 0.5 z^{-1}
den = [1];         % dénominateur (aucune rétroaction)

% Réponse impulsionnelle h(n)
[h, n] = impz(num, den, 50);   % 50 échantillons de h(n)

% Réponse fréquentielle H(w)
[H, f] = freqz(num, den, N, Fe);   % H(f) sur [0, Fe/2]

% Module et phase
amp   = abs(H);          % module
phase = angle(H);        % phase en radians

% Pôles et zéros
zeros_z = roots(num);
poles_z = roots(den);

% Affichages MATLAB classiques
figure;
stem(n, h, 'filled');
grid on;
title('Réponse impulsionnelle h(n) du filtre RIF');
xlabel('n'); ylabel('h(n)');

figure;
subplot(2,1,1);
plot(f, 20*log10(amp));
grid on;
xlabel('Fréquence (Hz)');
ylabel('|H(f)| en dB');
title('Module de la réponse fréquentielle H(f)');

subplot(2,1,2);
plot(f, phase);
grid on;
xlabel('Fréquence (Hz)');
ylabel('Phase (rad)');
title('Phase de H(f)');

figure;
zplane(num, den);
title('Pôles et zéros du filtre RIF');
        </code></pre>

        <h4>2.1.3 Graphes interactifs – Filtre RIF</h4>
        <p>
            Les figures ci-dessous correspondent aux questions de l’énoncé : réponse impulsionnelle, réponse fréquentielle
            (module et phase) et diagramme pôles–zéros.
        </p>

        <div id="plot_h_rif"></div>
        <div id="plot_H_rif_mag"></div>
        <div id="plot_H_rif_phase"></div>
        <div id="plot_pz_rif"></div>

        <h4>2.1.4 Commentaires sur la stabilité et l’interprétation fréquentielle</h4>
        <p>
            La réponse impulsionnelle du filtre est donnée par :
        </p>
        <p>
            

\[
            h(0) = 0{,}5,\quad h(1) = 0{,}5,\quad h(n) = 0 \text{ pour } n \ge 2
            \]


        </p>
        <p>
            La réponse impulsionnelle est donc de durée finie : le filtre est <strong>RIF</strong> (Réponse Impulsionnelle Finie)
            et par définition <strong>stable</strong> (la somme des valeurs absolues de \(h(n)\) est finie).
        </p>
        <p>
            La réponse fréquentielle s’écrit en remplaçant \(z = e^{j\omega}\) :
        </p>
        <p>
            

\[
            H(e^{j\omega}) = 0{,}5 + 0{,}5 e^{-j\omega}
                           = 0{,}5(1 + e^{-j\omega})
                           = \cos\left(\frac{\omega}{2}\right) e^{-j\omega/2}
            \]


        </p>
        <p>
            Le module vaut donc \(|H(e^{j\omega})| = |\cos(\omega/2)|\), maximal pour \(\omega = 0\) (fréquence nulle, composante continue)
            et nul pour \(\omega = \pi\) (fréquence de Nyquist). Ce comportement est typique d’un <strong>filtre passe-bas</strong>.
        </p>
        <p>
            Le diagramme pôles–zéros montre :
        </p>
        <ul>
            <li>un <strong>zéro</strong> en \(z = -1\), responsable de l’annulation du gain à haute fréquence ;</li>
            <li>un <strong>pôle</strong> en \(z = 0\), situé à l’intérieur du cercle unité, ce qui confirme la stabilité.</li>
        </ul>
        <p>
            On peut donc conclure que ce filtre est un <strong>moyenneur stable</strong>, qui lisse les signaux en atténuant
            les composantes rapides tout en conservant les variations lentes.
        </p>

    </section>

    

        <!-- 2.2 RII -->
    <h3>2.2 Analyse d’un filtre numérique RII</h3>

    <p>
        Dans cette partie, nous analysons un filtre numérique de type <strong>RII</strong> (Réponse Impulsionnelle Infinie)
        décrit par l’équation récurrente suivante :
    </p>
    <p>
        

\[
        y(n) = 0{,}0422\,x(n) + 0{,}0843\,x(n-1) + 1{,}3993\,y(n-1) - 0{,}5779\,y(n-2)
        \]


    </p>
    <p>
        Ce filtre présente une <strong>rétroaction</strong> (présence des termes en \(y(n-1)\) et \(y(n-2)\)), ce qui le
        distingue du filtre RIF précédent. Sa réponse impulsionnelle est en général de durée infinie, d’où l’appellation RII.
    </p>

    <h4>2.2.1 Fonction de transfert \(H(z)\)</h4>
    <p>
        En appliquant la transformée en Z à l’équation récurrente (conditions initiales nulles) :
    </p>
    <p>
        

\[
        Y(z) = 0{,}0422 X(z) + 0{,}0843 z^{-1} X(z) + 1{,}3993 z^{-1} Y(z) - 0{,}5779 z^{-2} Y(z)
        \]


    </p>
    <p>
        En regroupant les termes en \(Y(z)\) d’un côté :
    </p>
    <p>
        

\[
        Y(z)\left(1 - 1{,}3993 z^{-1} + 0{,}5779 z^{-2} \right)
        = X(z)\left(0{,}0422 + 0{,}0843 z^{-1}\right)
        \]


    </p>
    <p>
        La fonction de transfert est donc :
    </p>
    <p>
        

\[
        H(z) = \frac{Y(z)}{X(z)} = 
        \frac{0{,}0422 + 0{,}0843 z^{-1}}{1 - 1{,}3993 z^{-1} + 0{,}5779 z^{-2}}
        \]


    </p>
    <p>
        Le filtre possède ici un <strong>numérateur</strong> de degré 1 (en \(z^{-1}\)) et un <strong>dénominateur</strong> de degré 2,
        ce qui correspond à un filtre RII d’<strong>ordre 2</strong>.
    </p>

    <h4>2.2.2 Script MATLAB – \(H(z)\), \(h(n)\), \(H(\omega)\), pôles et zéros</h4>

    <pre><code>% Manipulation 2.2 : Filtre RII
% y(n) = 0.0422 x(n) + 0.0843 x(n-1) + 1.3993 y(n-1) - 0.5779 y(n-2)

clear all; close all; clc;

Fe = 8000;      % fréquence d'échantillonnage (Hz)
N  = 512;       % nombre de points pour la réponse fréquentielle

% Coefficients du filtre RII (en z^-1)
num = [0.0422 0.0843];
den = [1 -1.3993 0.5779];

% Réponse impulsionnelle h(n)
[h, n] = impz(num, den, 100);   % 100 échantillons pour observer l'évolution

% Réponse fréquentielle H(w)
[H, f] = freqz(num, den, N, Fe);   % H(f) sur [0, Fe/2]

% Module et phase
amp   = abs(H);          % module
phase = angle(H);        % phase en radians

% Pôles et zéros
zeros_z = roots(num);
poles_z = roots(den);

% Affichages MATLAB
figure;
stem(n, h, 'filled');
grid on;
title('Réponse impulsionnelle h(n) du filtre RII');
xlabel('n'); ylabel('h(n)');

figure;
subplot(2,1,1);
plot(f, 20*log10(amp));
grid on;
xlabel('Fréquence (Hz)');
ylabel('|H(f)| en dB');
title('Module de la réponse fréquentielle H(f)');

subplot(2,1,2);
plot(f, phase);
grid on;
xlabel('Fréquence (Hz)');
ylabel('Phase (rad)');
title('Phase de H(f)');

figure;
zplane(num, den);
title('Pôles et zéros du filtre RII');
    </code></pre>

    <h4>2.2.3 Graphes interactifs – Filtre RII</h4>
    <p>
        Comme pour le cas RIF, nous représentons ici de manière interactive :
    </p>
    <ul>
        <li>la réponse impulsionnelle \(h(n)\),</li>
        <li>le module de la réponse fréquentielle \(|H(f)|\) en dB,</li>
        <li>la phase de \(H(f)\),</li>
        <li>le diagramme des pôles et des zéros dans le plan Z.</li>
    </ul>

    <div id="plot_h_rii"></div>
    <div id="plot_H_rii_mag"></div>
    <div id="plot_H_rii_phase"></div>
    <div id="plot_pz_rii"></div>

    <h4>2.2.4 Commentaires sur la stabilité et l’interprétation fréquentielle</h4>
    <p>
        La stabilité d’un filtre RII se détermine à partir de la position de ses <strong>pôles</strong> dans le plan Z :
        le filtre est <strong>stable</strong> si et seulement si tous les pôles se trouvent <strong>à l’intérieur du cercle unité</strong>.
    </p>
    <p>
        En calculant les racines du dénominateur :
    </p>
    <p>
        

\[
        1 - 1{,}3993 z^{-1} + 0{,}5779 z^{-2} = 0
        \quad\Longleftrightarrow\quad
        z^{2} - 1{,}3993 z + 0{,}5779 = 0
        \]


    </p>
    <p>
        on trouve deux pôles complexes conjugués dont le module est strictement inférieur à 1. Ainsi, le filtre est
        <strong>asymptotiquement stable</strong> : sa réponse impulsionnelle décroît et reste bornée.
    </p>
    <p>
        La réponse fréquentielle obtenue par <code>freqz</code> montre un comportement de type <strong>passe-bas</strong> :
        le gain est élevé dans la zone des basses fréquences et atténué dans les hautes fréquences. La phase présente
        une variation non linéaire, typique des filtres RII.
    </p>
    <p>
        Comparé au filtre RIF précédent, ce filtre RII permet d’obtenir des spécifications fréquentielles plus sélectives
        avec un ordre relativement faible, au prix d’une structure avec rétroaction et d’une phase moins linéaire.
    </p>
    
    

    <!-- 3. Manipulation 3 – Synthèse de filtres passe-bas -->
    <section id="manip3" class="card">
        <h2><span class="section-number">3.</span>Manipulation 3 – Synthèse de filtres passe-bas</h2>

        <p>
            Dans cette manipulation, l’objectif n’est plus seulement d’analyser un filtre donné, mais de
            <strong>synthétiser</strong> des filtres passe-bas numériques répondant à des spécifications
            fréquentielles imposées. Deux approches complémentaires sont étudiées :
        </p>
        <ul>
            <li><strong>3.1</strong> Synthèse d’un filtre <strong>RII passe-bas</strong> via une approximation analogique (Butterworth, Tchebychev) puis transformation en numérique.</li>
            <li><strong>3.2</strong> Synthèse d’un filtre <strong>RIF passe-bas</strong> par la méthode de la fenêtre, à l’aide de la fonction <code>fir1</code>.</li>
        </ul>

        <!-- 3.1 Synthèse d'un filtre RII passe-bas -->
        <h3>3.1 Synthèse d’un filtre RII passe-bas</h3>

        <p>
            Les données fréquentielles sont :
        </p>
        <ul>
            <li><strong>Fréquence d’échantillonnage</strong> : \(F_e = 8000\,\text{Hz}\)</li>
            <li><strong>Bande passante</strong> : \(F_p = 1000\,\text{Hz}\)</li>
            <li><strong>Bande atténuée</strong> : \(F_a = 1500\,\text{Hz}\)</li>
            <li><strong>Atténuation en bande passante</strong> : \(A_p = 3\,\text{dB}\)</li>
            <li><strong>Atténuation en bande atténuée</strong> : \(A_a = 30\,\text{dB}\)</li>
        </ul>

        <p>
            L’idée est de concevoir d’abord un filtre <strong>analogique passe-bas</strong> (Butterworth ou Tchebychev),
            puis de le transformer en filtre numérique RII par :
        </p>
        <ul>
            <li>la <strong>transformation bilinéaire</strong> <code>bilinear()</code>,</li>
            <li>ou la <strong>méthode de l’invariance impulsionnelle</strong> <code>impinvar()</code>.</li>
        </ul>

        <h4>3.1.1 Normalisation et détermination des ordres</h4>

        <p>
            On commence par normaliser les fréquences analogiques :
        </p>
        <p>
            

\[
            \omega_p = 2\pi F_p,\quad \omega_a = 2\pi F_a,\quad F_e = 8000\,\text{Hz}
            \]


        </p>
        <p>
            Pour les fonctions MATLAB <code>buttord</code> et <code>cheb1ord</code> en mode analogique (option <code>'s'</code>),
            on utilise des pulsations normalisées :
        </p>
        <p>
            

\[
            \Omega_p = \frac{\omega_p}{\omega_c}, \quad \Omega_a = \frac{\omega_a}{\omega_c}
            \]


        </p>
        <p>
            Dans la pratique, on laisse MATLAB calculer l’ordre minimal et la pulsation de coupure optimale :
        </p>
         </section>
        <pre><code>% Manipulation 3.1 : Synthèse d'un filtre RII passe-bas (Butterworth et Tchebychev)

clear all; close all; clc;

Fe = 8000;    % Hz
Fp = 1000;    % Hz
Fa = 1500;    % Hz

Ap = 3;       % dB (ondulation max en bande passante)
Aa = 30;      % dB (atténuation min en bande atténuée)

% Fréquences numériques normalisées (par rapport à Fe/2)
wp = 2*pi*Fp;          % rad/s analogique (approximation)
wa = 2*pi*Fa;          % rad/s

% Normalisation pour utilisation analogique de buttord/cheb1ord ('s')
Wp = 2*pi*Fp;   % on peut travailler directement avec les pulsations
Wa = 2*pi*Fa;

% 1) Approximation de Butterworth
[Nb, Wcb] = buttord(Wp, Wa, Ap, Aa, 's');
[NumB, DenB] = butter(Nb, Wcb, 's');   % filtre analogique passe-bas de Butterworth

% 2) Approximation de Tchebychev (type I)
[Nc, Wcc] = cheb1ord(Wp, Wa, Ap, Aa, 's');
Ripple = Ap;  % ondulation en dB en bande passante
[NumC, DenC] = cheby1(Nc, Ripple, Wp, 'low', 's');

% Transformation en filtres numériques (méthode bilinéaire)
[NumzB, DenzB] = bilinear(NumB, DenB, Fe);
[NumzC, DenzC] = bilinear(NumC, DenC, Fe);

% Réponses fréquentielles
Nf = 512;
[HB, fB] = freqz(NumzB, DenzB, Nf, Fe);
[HC, fC] = freqz(NumzC, DenzC, Nf, Fe);

ampB = 20*log10(abs(HB));
ampC = 20*log10(abs(HC));
        </code></pre>

        <h4>3.1.2 Tracé et interprétation des réponses fréquentielles</h4>
         <div id="plot_RII_compare"></div>


        <p>
            On trace ensuite le module de la réponse en fréquence en dB pour les filtres de Butterworth et de Tchebychev :
        </p>

        <pre><code>figure;
plot(fB, ampB, 'b', 'LineWidth', 2); hold on;
plot(fC, ampC, 'r--', 'LineWidth', 2);
grid on;
xlabel('Fréquence (Hz)');
ylabel('|H(f)| (dB)');
legend('Butterworth', 'Tchebychev');
title('Comparaison des réponses en fréquence (RII passe-bas)');
        </code></pre>

        <h4>3.1.3 Stabilité et commentaires</h4>

        <p>
            En examinant les pôles des filtres numériques obtenus (avec <code>zplane</code> sur <code>NumzB, DenzB</code>
            et <code>NumzC, DenzC</code>), on vérifie que tous les pôles sont situés à l’intérieur du cercle unité :
            les filtres RII obtenus sont donc <strong>stables</strong>.
        </p>
        <p>
            Le filtre de <strong>Butterworth</strong> présente une <strong>réponse en fréquence monotone</strong> en bande
            passante et en bande atténuée, sans ondulations. Le filtre de <strong>Tchebychev</strong> type I, en revanche,
            introduit des <strong>ondulations en bande passante</strong>, ce qui permet d’obtenir une transition plus raide
            pour un ordre comparable.
        </p>
        <p>
            En pratique, le choix entre Butterworth et Tchebychev dépend du compromis souhaité entre :
        </p>
        <ul>
            <li>linéarité relative de la bande passante,</li>
            <li>raideur de la transition,</li>
            <li>complexité de réalisation (ordre du filtre).</li>
        </ul>

        <!-- 3.2 Synthèse d’un filtre RIF passe-bas -->
        <h3>3.2 Synthèse d’un filtre RIF passe-bas par la méthode de la fenêtre</h3>

        <p>
            On souhaite concevoir un filtre numérique RIF passe-bas, avec les spécifications suivantes :
        </p>
        <ul>
            <li>Bande passante : de 0 à \(2400\,\text{Hz}\).</li>
            <li>Bande atténuée : au-delà de \(3000\,\text{Hz}\).</li>
            <li>Atténuation souhaitée en bande atténuée : au moins \(40\,\text{dB}\).</li>
            <li>Fréquence d’échantillonnage : \(F_e = 8000\,\text{Hz}\).</li>
        </ul>

        <h4>3.2.1 Paramètre \(f_n\) pour la fonction <code>fir1</code></h4>

        <p>
            La fonction <code>fir1</code> attend un paramètre de fréquence normalisée \(f_n\) compris entre 0 et 1,
            défini par rapport à la fréquence de Nyquist \(F_e/2\). Pour un filtre passe-bas de coupure à
            \(F_c = 2400\,\text{Hz}\), on a :
        </p>
        <p>
            

\[
            f_n = \frac{F_c}{F_e/2} = \frac{2400}{4000} = 0{,}6
            \]


        </p>
        <p>
            Le paramètre à introduire dans <code>fir1</code> est donc <strong>0.6</strong>.
        </p>
      
        <h4>3.2.2 Script MATLAB – Synthèse pour différents ordres \(N\)</h4>

        <pre><code>% Manipulation 3.2 : Synthèse d'un filtre RIF passe-bas par fir1 (fenêtre rectangulaire)

clear all; close all; clc;

Fe = 8000;      % Hz
Fc = 2400;      % Hz (fréquence de coupure souhaitée)
fn = Fc / (Fe/2);   % fréquence normalisée pour fir1 -> 0.6

Nmin = 10; Nmax = 100; % ordre du filtre de 10 à 100
Nf = 512;

figure;
hold on; grid on;
xlabel('Fréquence (Hz)');
ylabel('|H(f)| (dB)');
title('Réponses fréquentielles pour différents ordres N (RIF passe-bas)');
colors = lines(10);

k = 1;
for N = Nmin:10:Nmax
    % Synthèse RIF avec fenêtre rectangulaire
    b = fir1(N, fn, boxcar(N+1)); % ou simplement fir1(N, fn) pour fenêtre rectangulaire
    a = 1;

    % Réponse impulsionnelle
    [h, n] = impz(b, a, 200);

    % Réponse fréquentielle
    [H, f] = freqz(b, a, Nf, Fe);
    amp = 20*log10(abs(H)+1e-12);

    % Tracé des réponses fréquentielles
    plot(f, amp, 'Color', colors(k,:), 'DisplayName', sprintf('N = %d', N));
    k = k+1;
end

legend('show');
        </code></pre>

        <h4>3.2.3 Visualisation, influence de l’ordre et choix d’un ordre minimal</h4>
         <div id="plot_RIF_multi"></div>

        <p>
            Les courbes obtenues pour différents ordres \(N\) montrent clairement que :
        </p>
        <ul>
            <li>Plus l’ordre \(N\) augmente, plus la <strong>pente de transition</strong> entre la bande passante et la bande atténuée devient raide.</li>
            <li>La <strong>fréquence de coupure à \(-3\,\text{dB}\)</strong> se rapproche de la valeur souhaitée \(F_c = 2400\,\text{Hz}\) quand \(N\) augmente.</li>
            <li>Un ordre trop faible ne permet pas d’atteindre l’atténuation de \(40\,\text{dB}\) au-delà de \(3000\,\text{Hz}\).</li>
        </ul>
        <p>
            En observant les courbes, on choisit un <strong>ordre minimal</strong> \(N_0\) tel que :
        </p>
        <ul>
            <li>l’atténuation en bande atténuée (au-delà de \(3000\,\text{Hz}\)) est d’au moins \(40\,\text{dB}\),</li>
            <li>la fréquence de coupure à \(-3\,\text{dB}\) est suffisamment proche de \(2400\,\text{Hz}\).</li>
        </ul>
        <p>
            Ce compromis permet d’obtenir un filtre RIF qui respecte les spécifications sans utiliser un ordre inutilement élevé,
            ce qui serait coûteux en calcul et en mémoire.
        </p>

    </section>

    <!-- 4. Conclusion générale -->
    <section id="conclusion" class="card">
        <h2><span class="section-number">4.</span>Conclusion générale</h2>

        <p>
            Ce TP a permis de parcourir l’essentiel de la chaîne de traitement des filtres numériques :
            de la manipulation des signaux élémentaires à la synthèse de filtres RIF et RII répondant à des
            spécifications fréquentielles. La première partie a rappelé le rôle fondamental de \(\delta(n)\)
            et \(u(n)\) comme signaux de test pour caractériser les systèmes linéaires invariants.
        </p>
        <p>
            L’analyse des filtres RIF et RII (Manipulation 2) a mis en évidence le lien entre l’<strong>équation récurrente</strong>,
            la <strong>fonction de transfert \(H(z)\)</strong>, la <strong>réponse impulsionnelle</strong>, la
            <strong>réponse en fréquence</strong> et la <strong>stabilité</strong> via la position des pôles dans le plan Z.
            Le filtre RIF étudié s’est révélé être un simple moyenneur passe-bas stable, tandis que le filtre RII d’ordre 2
            offre une sélectivité plus élevée, tout en restant stable.
        </p>
        <p>
            Enfin, la synthèse de filtres (Manipulation 3) a montré deux approches complémentaires :
        </p>
        <ul>
            <li>la <strong>synthèse RII</strong> à partir de filtres analogiques de Butterworth et Tchebychev, transformés en numériques par bilinéaire/invariance impulsionnelle ;</li>
            <li>la <strong>synthèse RIF</strong> par la méthode de la fenêtre, en jouant sur l’ordre du filtre pour respecter les contraintes de bande passante et d’atténuation.</li>
        </ul>
        <p>
            En résumé, ce TP m’a permis de relier la théorie des filtres (pôles, zéros, stabilité, réponses fréquentielles)
            à des outils concrets de conception sous MATLAB, tout en visualisant le comportement des filtres grâce aux tracés
            et aux graphiques interactifs. Ce type de travail renforce l’intuition sur le rôle des paramètres (ordre, type de filtre,
            méthode de synthèse) dans la qualité du filtrage obtenu.
        </p>
    </section>
    
       

<section id="conclusion" class="card">
        <h2><span class="section-number">4.</span>Conclusion générale</h2>

        <p>
            Ce TP a permis d’explorer en profondeur les filtres numériques RIF et RII, depuis leur analyse
            jusqu’à leur synthèse. Nous avons étudié les réponses impulsionnelles, les réponses fréquentielles,
            la stabilité via les pôles, ainsi que les méthodes de conception analogique-numérique et FIR.
        </p>

        <p>
            La comparaison entre les filtres RIF et RII a mis en évidence leurs avantages respectifs :
            simplicité et stabilité automatique pour les RIF, sélectivité accrue pour les RII. La synthèse
            par Butterworth et Tchebychev a montré l’importance du compromis entre ondulation et raideur
            de la transition. Enfin, la méthode FIR par fenêtre a illustré l’impact direct de l’ordre du filtre
            sur la qualité du filtrage.
        </p>

        <p>
            Ce TP m’a permis de renforcer ma compréhension des systèmes linéaires invariants, de la transformée
            en Z, et des outils MATLAB de conception de filtres. Les visualisations interactives ont facilité
            l’interprétation des résultats et la compréhension des phénomènes fréquentiels.
        </p>
    </section>

</main>

<footer>
    TP Nº2 – Filtres numériques • Master 1 AII – USTHB • DAHANE AHMED LAMINE
</footer>
         <!-- ===================== SCRIPTS PLOTLY – PARTIE 1 (Manip 1 + 2.1) ===================== -->
<script>
    // Charger le JSON depuis un fichier externe
    fetch("data.json")
        .then(response => response.json())
        .then(data => {
            // Fonction pour tracer un signal
            function plotSignal(divId, x, y, title) {
                Plotly.newPlot(divId, [{
                    x: x,
                    y: y,
                    type: 'scatter',
                    mode: 'markers+lines',
                    marker: { size: 8, color: '#9b5cff' }
                }], {
                    title: title,
                    xaxis: { title: 'n' },
                    yaxis: { title: 'Amplitude' },
                    plot_bgcolor: '#050816',
                    paper_bgcolor: '#050914',
                    font: { color: '#e5e9ff' }
                });
            }

            // Boucle sur chaque signal
            data.signals.forEach(sig => {
                // Créer un div pour chaque signal
                const divId = "plot_" + sig.name.replace(/\W/g, "");
                const div = document.createElement("div");
                div.id = divId;
                document.body.appendChild(div);

                // Tracer le signal
                plotSignal(divId, data.n, sig.values, sig.name);
            });
        });
</script>

</body>
</html>   
